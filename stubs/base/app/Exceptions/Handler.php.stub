<?php

namespace {{namespace}}\Exceptions;

use Exception;
use Illuminate\Contracts\Debug\ExceptionHandler as ExceptionHandlerContract;
use Psr\Log\LoggerInterface;

class Handler implements ExceptionHandlerContract
{
    /**
     * The logger instance.
     *
     * @var \Psr\Log\LoggerInterface
     */
    protected $log;

    /**
     * Create a new exception handler instance.
     *
     * @param  \Psr\Log\LoggerInterface  $log
     * @return void
     */
    public function __construct(LoggerInterface $log)
    {
        $this->log = $log;
    }

    /**
     * Report or log an exception.
     *
     * @param  \Exception  $e
     * @return void
     */
    public function report(Exception $e)
    {
        $this->log->error(
            $e->getMessage(),
            ['exception' => $e]
        );
    }

    /**
     * Render an exception into an HTTP response.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Exception  $e
     * @return \Symfony\Component\HttpFoundation\Response
     */
    public function render($request, Exception $e)
    {
        // For a WordPress plugin, we might just log and return a generic error.
        // Or if in debug mode, show a simpler message.
        if (WP_DEBUG) {
            return new \Symfony\Component\HttpFoundation\Response(
                'An error occurred: ' . $e->getMessage() . '<pre>' . $e->getTraceAsString() . '</pre>',
                500
            );
        }

        return new \Symfony\Component\HttpFoundation\Response('An internal error occurred.', 500);
    }

    /**
     * Render an exception to the console.
     *
     * @param  \Symfony\Component\Console\Output\OutputInterface  $output
     * @param  \Exception  $e
     * @return void
     */
    public function renderForConsole($output, Exception $e)
    {
        // For CLI, we can output the full error.
        $output->writeln($e->getMessage());
        $output->writeln($e->getTraceAsString());
    }
}
