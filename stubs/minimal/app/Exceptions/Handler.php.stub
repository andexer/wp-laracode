<?php

namespace {{namespace}}\Exceptions;

use Throwable;
use Exception;
use Illuminate\Contracts\Debug\ExceptionHandler as ExceptionHandlerContract;
use Illuminate\Validation\ValidationException;
use {{namespace}}\Helpers\LogHelper;
use Psr\Log\LoggerInterface;

class Handler implements ExceptionHandlerContract
{
    /**
     * The logger instance.
     *
     * @var \Psr\Log\LoggerInterface
     */
    protected $log;

    /**
     * Exceptions that should not be reported.
     *
     * @var array
     */
    protected array $dontReport = [
        ValidationException::class,
    ];

    /**
     * Create a new exception handler instance.
     *
     * @param \Psr\Log\LoggerInterface $log
     * @return void
     */
    public function __construct(LoggerInterface $log)
    {
        $this->log = $log;
    }

    /**
     * Report or log an exception.
     *
     * @param \Exception $e
     * @return void
     */
    public function report(Throwable $e)
    {
        if ($this->shouldntReport($e)) {
            return;
        }

        LogHelper::error('Exception occurred', [
            'exception' => get_class($e),
            'message' => $e->getMessage(),
            'file' => $e->getFile(),
            'line' => $e->getLine(),
            'user_id' => get_current_user_id(),
            'request_url' => $_SERVER['REQUEST_URI'] ?? 'unknown',
        ]);

        $this->log->error($e->getMessage(), ['exception' => $e]);
    }

    /**
     * Determine if the exception should not be reported.
     *
     * @param \Exception $e
     * @return bool
     */
    protected function shouldntReport(Throwable $e): bool
    {
        foreach ($this->dontReport as $type) {
            if ($e instanceof $type) {
                return true;
            }
        }

        return false;
    }

    /**
     * Determine if the exception should be reported.
     *
     * @param \Throwable $e
     * @return bool
     */
    public function shouldReport(Throwable $e)
    {
        return ! $this->shouldntReport($e);
    }

    /**
     * Render an exception into an HTTP response.
     *
     * @param \Illuminate\Http\Request $request
     * @param \Exception $e
     * @return \Symfony\Component\HttpFoundation\Response
     */
    public function render($request, Throwable $e)
    {
        if ($this->expectsJson($request)) {
            return $this->renderApiException($request, $e);
        }

        return $this->renderWebException($request, $e);
    }

    /**
     * Render an exception for API requests.
     *
     * @param mixed $request
     * @param \Exception $e
     * @return \Symfony\Component\HttpFoundation\Response
     */
    protected function renderApiException($request, Throwable $e)
    {
        $statusCode = 500;
        $message = __('Internal server error.', '{{slug}}');
        $errors = [];

        if ($e instanceof ValidationException) {
            $statusCode = 422;
            $message = __('Validation failed.', '{{slug}}');
            $errors = $e->errors();
        } elseif ($e instanceof \Illuminate\Auth\Access\AuthorizationException) {
            $statusCode = 403;
            $message = __('Access denied.', '{{slug}}');
        }

        $response = [
            'success' => false,
            'message' => $message,
            'errors' => $errors,
        ];

        // Include debug info only in debug mode
        if (defined('WP_DEBUG') && WP_DEBUG) {
            $response['debug'] = [
                'exception' => get_class($e),
                'message' => $e->getMessage(),
                'file' => $e->getFile(),
                'line' => $e->getLine(),
            ];
        }

        return new \Symfony\Component\HttpFoundation\JsonResponse($response, $statusCode);
    }

    /**
     * Render an exception for web requests.
     *
     * @param mixed $request
     * @param \Exception $e
     * @return \Symfony\Component\HttpFoundation\Response
     */
    protected function renderWebException($request, Throwable $e)
    {
        if (defined('WP_DEBUG') && WP_DEBUG) {
            return new \Symfony\Component\HttpFoundation\Response(
                '<h1>An error occurred</h1>' .
                '<p><strong>Message:</strong> ' . esc_html($e->getMessage()) . '</p>' .
                '<pre>' . esc_html($e->getTraceAsString()) . '</pre>',
                500
            );
        }

        return new \Symfony\Component\HttpFoundation\Response(
            '<h1>' . esc_html__('An error occurred', '{{slug}}') . '</h1>' .
            '<p>' . esc_html__('Please try again later or contact support.', '{{slug}}') . '</p>',
            500
        );
    }

    /**
     * Check if the request expects JSON.
     *
     * @param mixed $request
     * @return bool
     */
    protected function expectsJson($request): bool
    {
        if ($request instanceof \WP_REST_Request) {
            return true;
        }

        if (method_exists($request, 'expectsJson')) {
            return $request->expectsJson();
        }

        $accept = $_SERVER['HTTP_ACCEPT'] ?? '';
        return str_contains($accept, 'application/json');
    }

    /**
     * Render an exception to the console.
     *
     * @param \Symfony\Component\Console\Output\OutputInterface $output
     * @param \Exception $e
     * @return void
     */
    public function renderForConsole($output, Throwable $e)
    {
        $output->writeln('<error>' . $e->getMessage() . '</error>');
        $output->writeln($e->getTraceAsString());
    }
}
