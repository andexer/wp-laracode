<?php

namespace {{namespace}}\WordPress\Providers;

use Illuminate\Filesystem\Filesystem;
use Illuminate\Support\Facades\Facade;
use Illuminate\Support\ServiceProvider;
use Illuminate\View\Compilers\BladeCompiler;
use Illuminate\View\Engines\CompilerEngine;
use Illuminate\View\Engines\EngineResolver;
use Illuminate\View\Factory;
use Illuminate\View\FileViewFinder;
use Livewire\LivewireManager;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use {{namespace}}\WordPress\Helpers\Nonce;

/**
 * Livewire Service Provider
 *
 * Integrates Livewire 4 with WordPress in a modular and isolated way.
 * Each wp-laracode plugin has its own Livewire instance to prevent conflicts.
 */
class LivewireServiceProvider extends ServiceProvider
{
    /**
     * Plugin-specific nonce action for Livewire requests.
     */
    protected const NONCE_ACTION = '{{slug}}_livewire';

    /**
     * Register services.
     */
    public function register(): void
    {
        Facade::setFacadeApplication($this->app);

        $this->registerViewFactory();
        $this->registerLivewire();
    }

    /**
     * Bootstrap services.
     */
    public function boot(): void
    {
        $this->registerBladeDirectives();
        $this->enqueueAssets();
        $this->registerRestApiEndpoint();
    }

    /**
     * Register the view factory with Blade compiler.
     */
    protected function registerViewFactory(): void
    {
        $this->app->singleton('view', function ($app) {
            $resolver = new EngineResolver;

            // Use configured view path or default to resources/views
            $defaultPath = $this->app->resourcePath('views');
            $viewsPath = $app['config']->get('livewire.view_path', $defaultPath);

            // Ensure views directory exists
            if (!is_dir($viewsPath)) {
                @mkdir($viewsPath, 0755, true);
            }

            $finder = new FileViewFinder(new Filesystem, [$viewsPath]);
            $factory = new Factory($resolver, $finder, $app->make(\Illuminate\Contracts\Events\Dispatcher::class));
            $factory->setContainer($this->app);

            $compiledPath = $this->app->storagePath() . '/framework/views';
            if (!is_dir($compiledPath)) {
                @mkdir($compiledPath, 0755, true);
            }

            $compiler = new BladeCompiler(new Filesystem, $compiledPath);
            $resolver->register('blade', fn() => new CompilerEngine($compiler));

            return $factory;
        });
    }

    /**
     * Register Livewire manager.
     */
    protected function registerLivewire(): void
    {
        $this->app->singleton('livewire', fn() => new LivewireManager);
    }

    /**
     * Register Blade directives for Livewire.
     */
    protected function registerBladeDirectives(): void
    {
        $this->app->make('view')->getEngineResolver()->resolve('blade')->getCompiler()->directive('livewire', function ($expression) {
            return "<?php echo \\Livewire\\Livewire::mount({$expression}); ?>";
        });
    }

    /**
     * Enqueue Livewire assets using proper WordPress hooks.
     *
     * Uses Livewire's native FrontendAssets mechanism for proper
     * script/style injection with automatic hydration setup.
     */
    protected function enqueueAssets(): void
    {
        // Frontend pages
        add_action('wp_head', [$this, 'outputStyles'], 999);
        add_action('wp_footer', [$this, 'outputScripts'], 999);

        // Admin pages
        add_action('admin_head', [$this, 'outputStyles'], 999);
        add_action('admin_footer', [$this, 'outputScripts'], 999);

        // Login page (if needed)
        add_action('login_head', [$this, 'outputStyles'], 999);
        add_action('login_footer', [$this, 'outputScripts'], 999);
    }

    /**
     * Output Livewire styles in the head.
     */
    public function outputStyles(): void
    {
        if (!class_exists(\Livewire\Mechanisms\FrontendAssets\FrontendAssets::class)) {
            return;
        }

        echo \Livewire\Mechanisms\FrontendAssets\FrontendAssets::styles();
    }

    /**
     * Output Livewire scripts with plugin-specific configuration.
     */
    public function outputScripts(): void
    {
        if (!class_exists(\Livewire\Mechanisms\FrontendAssets\FrontendAssets::class)) {
            return;
        }

        // Output Livewire's core scripts manually pointing to our proxy
        // echo \Livewire\Mechanisms\FrontendAssets\FrontendAssets::scripts(); // Don't use this as it points to /livewire/...
        
        $assetUrl = rest_url('{{slug}}/v1/livewire.js');
        echo '<script src="' . esc_url($assetUrl) . '" data-turbo-eval="false" data-turbolinks-eval="false"></script>';

        // Inject plugin-specific nonce configuration for WordPress REST API auth
        $this->outputNonceScript();
    }

    /**
     * Output inline script to inject WordPress nonce into Livewire requests.
     *
     * This ensures each plugin's Livewire requests are authenticated
     * with WordPress nonce verification for security.
     */
    protected function outputNonceScript(): void
    {
        $config = [
            'updateUri' => rest_url('{{slug}}/v1/livewire/update'),
            'assetUrl' => rest_url('{{slug}}/v1/livewire.js'), // Use REST proxy
            'nonce' => Nonce::create(self::NONCE_ACTION),
        ];

        $configJson = json_encode($config);
        $pluginVar = '{{constantPrefix}}';

        echo <<<HTML
<script data-livewire-config="{{slug}}">
(function() {
    window.LivewireConfig_{$pluginVar} = {$configJson};

    // Override fetch for this plugin's Livewire requests
    var originalFetch = window.fetch;
    window.fetch = function(url, options) {
        if (typeof url === 'string' && url.includes('/{{slug}}/v1/livewire/')) {
            options = options || {};
            options.headers = options.headers || {};
            options.headers['X-WP-Nonce'] = window.LivewireConfig_{$pluginVar}.nonce;
        }
        return originalFetch.call(this, url, options);
    };
})();
</script>
HTML;
    }

    /**
     * Register REST API endpoints for Livewire.
     */
    protected function registerRestApiEndpoint(): void
    {
        add_action('rest_api_init', function () {
            // Endpoint for Livewire updates
            register_rest_route('{{slug}}/v1', '/livewire/update', [
                'methods' => 'POST',
                'callback' => [$this, 'handleLivewireRequest'],
                'permission_callback' => [$this, 'checkPermissions'],
            ]);

            // Endpoint for serving Livewire Assets (JS/CSS) to avoid 404s
            register_rest_route('{{slug}}/v1', '/livewire.js', [
                'methods' => 'GET',
                'callback' => [$this, 'handleAssetRequest'],
                'permission_callback' => '__return_true', // Public asset
            ]);

            register_rest_route('{{slug}}/v1', '/livewire.css', [
                'methods' => 'GET',
                'callback' => [$this, 'handleAssetRequest'],
                'permission_callback' => '__return_true', // Public asset
            ]);

            // Legacy endpoint (optional)
            register_rest_route('{{slug}}/v1', '/livewire/message/(?P<name>[\w-]+)', [
                'methods' => 'POST',
                'callback' => [$this, 'handleLivewireRequest'],
                'permission_callback' => [$this, 'checkPermissions'],
            ]);
        });
    }

    /**
     * Handle Livewire Asset Requests (Proxy).
     *
     * @param \WP_REST_Request $request
     */
    public function handleAssetRequest(\WP_REST_Request $request)
    {
        $route = $request->get_route();
        $isJs = str_ends_with($route, '.js');
        $contentType = $isJs ? 'application/javascript' : 'text/css';
        
        // Attempt to locate the asset in the vendor directory
        // This assumes composer install has been run
        $baseDir = {{constantPrefix}}_PATH . 'vendor/livewire/livewire/dist';
        $file = $isJs ? 'livewire.js' : 'livewire.css';
        $path = $baseDir . '/' . $file;

        if (!file_exists($path)) {
             // Fallback or error
             return new \WP_Error('asset_not_found', 'Livewire asset not found', ['status' => 404]);
        }

        $content = file_get_contents($path);
        
        // Return raw content with correct headers
        header('Content-Type: ' . $contentType);
        header('Cache-Control: public, max-age=31536000');
        echo $content;
        exit;
    }

    /**
     * Check permissions for the REST request.
     *
     * @param \WP_REST_Request $request
     * @return bool
     */
    public function checkPermissions(\WP_REST_Request $request): bool
    {
        // 1. Verify Nonce (Strict Header Check)
        if (!$this->verifyNonce($request)) {
            return false;
        }

        // 2. Check User Capabilities with filter
        // Default to 'read' to allow authenticated users, use filter to customize
        $capability = apply_filters('{{slug}}_livewire_capability', 'read', $request);

        if (!current_user_can($capability)) {
            return false;
        }

        return true;
    }

    /**
     * Handle the Livewire request.
     *
     * @param \WP_REST_Request $wpRequest
     */
    public function handleLivewireRequest(\WP_REST_Request $wpRequest)
    {
        // Bridge WP_REST_Request to a Symfony Request
        $symfonyRequest = Request::createFromGlobals();

        try {
            // Let Livewire handle the request and get a Symfony Response
            $livewireResponse = $this->app->make('livewire')->getHttpConnectionHandler()->handle($symfonyRequest);

            // Bridge the Symfony Response back to WordPress
            $this->sendResponse($livewireResponse);
        } catch (\Exception $e) {
            // Log the error securely (hide details in production)
            if (defined('WP_DEBUG') && WP_DEBUG) {
                error_log('[{{slug}}] Livewire error: ' . $e->getMessage());
            }

            wp_send_json_error([
                'message' => __('An error occurred processing the request.', '{{slug}}'),
            ], 500);
        }
    }

    /**
     * Send the Symfony response back to the client.
     */
    protected function sendResponse(Response $response): void
    {
        http_response_code($response->getStatusCode());

        foreach ($response->headers->allPreserveCase() as $name => $values) {
            foreach ($values as $value) {
                header($name . ': ' . $value, false);
            }
        }

        echo $response->getContent();
        exit;
    }

    /**
     * Verify nonce for security with stricter checks.
     *
     * @param \WP_REST_Request $request
     * @return bool
     */
    public function verifyNonce(\WP_REST_Request $request): bool
    {
        // Strict: Only accept nonce from Header, not GET/POST params
        $nonce = $request->get_header('X-WP-Nonce');

        if (empty($nonce)) {
            return false;
        }

        // Verify using WordPress function (returns 1 or 2 if valid)
        $result = wp_verify_nonce($nonce, self::NONCE_ACTION);

        return (bool) $result;
    }
}
